<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Exam Creator</title>
    <style>
        :root {
            --font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            --color-white: #ffffff;
            --color-black: #000000;
            --color-gray-100: #f8f9fa;
            --color-gray-200: #e9ecef;
            --color-gray-300: #dee2e6;
            --color-gray-600: #6c757d;
            --color-green: #4caf50;
            --color-green-dark: #45a049;
            --color-blue: #2196f3;
            --color-blue-dark: #0b7dda;
            --color-red: #dc3545;
            --border-radius: 8px;
            --spacing-sm: 8px;
            --spacing-md: 16px;
            --spacing-lg: 24px;
        }

        body {
            font-family: var(--font-family);
            margin: 0;
            padding: 20px;
            background-color: var(--color-gray-100);
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            background-color: var(--color-white);
            padding: var(--spacing-lg);
            border-radius: var(--border-radius);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        h1, h2, h3 {
            margin-top: 0;
        }

        .form-group {
            margin-bottom: var(--spacing-md);
        }

        label {
            display: block;
            margin-bottom: var(--spacing-sm);
            font-weight: 500;
        }

        input[type="text"],
        textarea,
        input[type="datetime-local"],
        input[type="number"] {
            width: 100%;
            padding: 10px;
            border: 1px solid var(--color-gray-300);
            border-radius: 4px;
            font-family: inherit;
            box-sizing: border-box;
        }

        textarea {
            min-height: 100px;
            resize: vertical;
        }

        .btn {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 10px 15px;
            border-radius: 4px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            border: none;
            transition: all 0.2s ease;
        }

        .btn-green {
            background-color: var(--color-green);
            color: var(--color-white);
        }

        .btn-green:hover {
            background-color: var(--color-green-dark);
        }

        .btn-blue {
            background-color: var(--color-blue);
            color: var(--color-white);
        }

        .btn-blue:hover {
            background-color: var(--color-blue-dark);
        }

        .btn-red {
            background-color: var(--color-red);
            color: var(--color-white);
        }

        .btn-red:hover {
            background-color: #bd2130;
        }

        .import-export-actions {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            align-items: center;
            flex-wrap: wrap;
        }

        .questions-container {
            margin-top: var(--spacing-lg);
        }

        .question-card {
            border: 1px solid var(--color-gray-300);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            margin-bottom: var(--spacing-md);
            background-color: var(--color-white);
        }

        .question-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--spacing-sm);
        }

        .question-type-selector {
            margin-bottom: var(--spacing-md);
            display: flex;
            gap: var(--spacing-sm);
        }

        .question-type-selector button {
            padding: 8px 16px;
            border: 1px solid var(--color-black);
            border-radius: 4px;
            background-color: var(--color-white);
            cursor: pointer;
        }

        .question-type-selector button.active {
            background-color: var(--color-black);
            color: var(--color-white);
        }

        .options-list {
            margin-top: var(--spacing-md);
        }

        .option-item {
            display: flex;
            align-items: center;
            margin-bottom: var(--spacing-sm);
            gap: var(--spacing-sm);
        }

        .option-item input[type="text"] {
            flex: 1;
        }

        .remove-btn {
            background-color: var(--color-red);
            color: var(--color-white);
            border: none;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 16px;
            padding: 0;
        }

        .actions {
            display: flex;
            justify-content: space-between;
            margin-top: var(--spacing-md);
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 46px;
            height: 24px;
            margin-right: 10px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 24px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .toggle-slider {
            background-color: var(--color-black);
        }

        input:checked + .toggle-slider:before {
            transform: translateX(22px);
        }

        .multiple-answer-toggle {
            display: flex;
            align-items: center;
            margin-bottom: var(--spacing-md);
        }

        .notification {
            padding: 10px 15px;
            border-radius: 4px;
            margin-bottom: 15px;
        }

        .notification.success {
            background-color: rgba(76, 175, 80, 0.1);
            border: 1px solid rgba(76, 175, 80, 0.2);
            color: var(--color-green);
        }

        .notification.error {
            background-color: rgba(220, 53, 69, 0.1);
            border: 1px solid rgba(220, 53, 69, 0.2);
            color: var(--color-red);
        }

        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Exam Creator</h1>
        
        <div id="notifications"></div>
        
        <div class="import-export-actions">
            <button id="exportBtn" class="btn btn-green">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                    <path d="M.5 9.9a.5.5 0 0 1 .5.5v2.5a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2.5a.5.5 0 0 1 1 0v2.5a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2v-2.5a.5.5 0 0 1 .5-.5z"/>
                    <path d="M7.646 11.854a.5.5 0 0 0 .708 0l3-3a.5.5 0 0 0-.708-.708L8.5 10.293V1.5a.5.5 0 0 0-1 0v8.793L5.354 8.146a.5.5 0 1 0-.708.708l3 3z"/>
                </svg>
                Export Exam
            </button>
            <button id="importBtn" class="btn btn-blue">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                    <path d="M.5 9.9a.5.5 0 0 1 .5.5v2.5a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2.5a.5.5 0 0 1 1 0v2.5a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2v-2.5a.5.5 0 0 1 .5-.5z"/>
                    <path d="M7.646 1.146a.5.5 0 0 1 .708 0l3 3a.5.5 0 0 1-.708.708L8.5 2.707V11.5a.5.5 0 0 1-1 0V2.707L5.354 4.854a.5.5 0 1 1-.708-.708l3-3z"/>
                </svg>
                Import Exam
            </button>
            <input type="file" id="importFile" accept=".json" style="display:none;">
        </div>

        <div class="exam-details">
            <h2>Exam Details</h2>
            <div class="form-group">
                <label for="examTitle">Title <span style="color: red;">*</span></label>
                <input type="text" id="examTitle" placeholder="Enter exam title" required>
            </div>
            <div class="form-group">
                <label for="examDescription">Description</label>
                <textarea id="examDescription" placeholder="Enter exam description (optional)"></textarea>
            </div>
            <div class="form-group">
                <label for="examDueDate">Due Date</label>
                <input type="datetime-local" id="examDueDate">
            </div>
        </div>

        <div class="questions-container">
            <h2>Questions</h2>
            <div id="questionsList"></div>
            
            <button id="addQuestionBtn" class="btn btn-blue">Add New Question</button>
        </div>
    </div>

    <!-- Question Template (Hidden) -->
    <template id="questionTemplate">
        <div class="question-card">
            <div class="question-header">
                <h3>Question <span class="question-number"></span></h3>
                <button class="btn btn-red remove-question-btn">Remove</button>
            </div>
            
            <div class="question-type-selector">
                <button type="button" class="type-btn active" data-type="mcq">Multiple Choice</button>
                <button type="button" class="type-btn" data-type="identification">Identification</button>
            </div>
            
            <div class="form-group">
                <label for="question-text">Question Text <span style="color: red;">*</span></label>
                <textarea class="question-text" placeholder="Enter your question"></textarea>
            </div>
            
            <div class="multiple-answer-toggle">
                <label class="toggle-switch">
                    <input type="checkbox" class="allow-multiple">
                    <span class="toggle-slider"></span>
                </label>
                <span>Allow multiple correct answers</span>
            </div>
            
            <div class="mcq-options">
                <label>Options <span style="color: red;">*</span></label>
                <div class="options-list">
                    <!-- Options will be added here -->
                </div>
                <button type="button" class="btn btn-blue add-option-btn">Add Option</button>
            </div>
            
            <div class="identification-answer hidden">
                <label>Correct Answer <span style="color: red;">*</span></label>
                <div class="single-answer">
                    <input type="text" class="correct-answer" placeholder="Enter the correct answer">
                </div>
                <div class="multiple-answers hidden">
                    <div class="multiple-answers-list">
                        <div class="option-item">
                            <input type="text" class="multiple-answer" placeholder="Enter a correct answer">
                            <button type="button" class="remove-btn">×</button>
                        </div>
                    </div>
                    <button type="button" class="btn btn-blue add-answer-btn">Add Another Answer</button>
                </div>
            </div>
            
            <div class="form-group">
                <label for="points">Points</label>
                <input type="number" class="question-points" min="1" value="1">
            </div>
        </div>
    </template>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            let questions = [];
            let questionCounter = 0;
            
            // DOM Elements
            const examTitle = document.getElementById('examTitle');
            const examDescription = document.getElementById('examDescription');
            const examDueDate = document.getElementById('examDueDate');
            const questionsList = document.getElementById('questionsList');
            const addQuestionBtn = document.getElementById('addQuestionBtn');
            const exportBtn = document.getElementById('exportBtn');
            const importBtn = document.getElementById('importBtn');
            const importFile = document.getElementById('importFile');
            const notificationsDiv = document.getElementById('notifications');
            
            // Add a new question
            addQuestionBtn.addEventListener('click', addNewQuestion);
            
            // Export exam
            exportBtn.addEventListener('click', exportExam);
            
            // Import exam
            importBtn.addEventListener('click', () => {
                importFile.click();
            });
            
            importFile.addEventListener('change', importExam);
            
            // Add first question by default
            addNewQuestion();
            
            function addNewQuestion() {
                questionCounter++;
                
                // Clone the template
                const template = document.getElementById('questionTemplate');
                const questionCard = document.importNode(template.content, true).querySelector('.question-card');
                
                // Set question number
                questionCard.querySelector('.question-number').textContent = questionCounter;
                
                // Add unique IDs to form elements
                const questionId = `question-${Date.now()}-${questionCounter}`;
                questionCard.dataset.id = questionId;
                
                // Setup event listeners for this question card
                setupQuestionCardEvents(questionCard);
                
                // Add default options for MCQ
                const optionsList = questionCard.querySelector('.options-list');
                for (let i = 0; i < 4; i++) {
                    addOption(optionsList);
                }
                
                // Add to DOM
                questionsList.appendChild(questionCard);
                
                // Add to questions array
                questions.push({
                    id: questionId,
                    type: 'mcq',
                    question: '',
                    options: ['', '', '', ''],
                    correctAnswerIndex: null,
                    allowMultipleAnswers: false,
                    correctAnswerIndices: [],
                    correctAnswer: '',
                    correctAnswerList: [],
                    points: 1
                });
            }
            
            function setupQuestionCardEvents(card) {
                // Type selector buttons
                const typeButtons = card.querySelectorAll('.type-btn');
                typeButtons.forEach(btn => {
                    btn.addEventListener('click', () => {
                        // Update active state
                        typeButtons.forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        
                        // Show/hide relevant sections
                        const type = btn.dataset.type;
                        const mcqOptions = card.querySelector('.mcq-options');
                        const identificationAnswer = card.querySelector('.identification-answer');
                        
                        if (type === 'mcq') {
                            mcqOptions.classList.remove('hidden');
                            identificationAnswer.classList.add('hidden');
                        } else {
                            mcqOptions.classList.add('hidden');
                            identificationAnswer.classList.remove('hidden');
                        }
                        
                        // Update question object
                        const questionId = card.dataset.id;
                        const questionIndex = questions.findIndex(q => q.id === questionId);
                        if (questionIndex !== -1) {
                            questions[questionIndex].type = type;
                        }
                    });
                });
                
                // Multiple answers toggle
                const multipleAnswersToggle = card.querySelector('.allow-multiple');
                multipleAnswersToggle.addEventListener('change', () => {
                    const isMultiple = multipleAnswersToggle.checked;
                    const questionId = card.dataset.id;
                    const questionIndex = questions.findIndex(q => q.id === questionId);
                    
                    if (questionIndex !== -1) {
                        questions[questionIndex].allowMultipleAnswers = isMultiple;
                        
                        // Update UI based on question type
                        const type = questions[questionIndex].type;
                        if (type === 'mcq') {
                            // For MCQ, update the input type (radio vs checkbox)
                            updateMCQInputType(card, isMultiple);
                        } else {
                            // For identification, show/hide multiple answers section
                            const singleAnswer = card.querySelector('.single-answer');
                            const multipleAnswers = card.querySelector('.multiple-answers');
                            
                            if (isMultiple) {
                                singleAnswer.classList.add('hidden');
                                multipleAnswers.classList.remove('hidden');
                            } else {
                                singleAnswer.classList.remove('hidden');
                                multipleAnswers.classList.add('hidden');
                            }
                        }
                    }
                });
                
                // Add option button
                const addOptionBtn = card.querySelector('.add-option-btn');
                addOptionBtn.addEventListener('click', () => {
                    const optionsList = card.querySelector('.options-list');
                    addOption(optionsList);
                    
                    // Update question object
                    const questionId = card.dataset.id;
                    const questionIndex = questions.findIndex(q => q.id === questionId);
                    if (questionIndex !== -1) {
                        questions[questionIndex].options.push('');
                    }
                });
                
                // Add answer button (for multiple identification answers)
                const addAnswerBtn = card.querySelector('.add-answer-btn');
                addAnswerBtn.addEventListener('click', () => {
                    const answersList = card.querySelector('.multiple-answers-list');
                    addIdentificationAnswer(answersList);
                    
                    // Update question object
                    const questionId = card.dataset.id;
                    const questionIndex = questions.findIndex(q => q.id === questionId);
                    if (questionIndex !== -1) {
                        if (!Array.isArray(questions[questionIndex].correctAnswerList)) {
                            questions[questionIndex].correctAnswerList = [];
                        }
                        questions[questionIndex].correctAnswerList.push('');
                    }
                });
                
                // Question text input
                const questionTextInput = card.querySelector('.question-text');
                questionTextInput.addEventListener('input', () => {
                    const questionId = card.dataset.id;
                    const questionIndex = questions.findIndex(q => q.id === questionId);
                    if (questionIndex !== -1) {
                        questions[questionIndex].question = questionTextInput.value;
                    }
                });
                
                // Points input
                const pointsInput = card.querySelector('.question-points');
                pointsInput.addEventListener('input', () => {
                    const questionId = card.dataset.id;
                    const questionIndex = questions.findIndex(q => q.id === questionId);
                    if (questionIndex !== -1) {
                        questions[questionIndex].points = parseInt(pointsInput.value) || 1;
                    }
                });
                
                // Single correct answer input
                const correctAnswerInput = card.querySelector('.correct-answer');
                correctAnswerInput.addEventListener('input', () => {
                    const questionId = card.dataset.id;
                    const questionIndex = questions.findIndex(q => q.id === questionId);
                    if (questionIndex !== -1) {
                        questions[questionIndex].correctAnswer = correctAnswerInput.value;
                    }
                });
                
                // Remove question button
                const removeQuestionBtn = card.querySelector('.remove-question-btn');
                removeQuestionBtn.addEventListener('click', () => {
                    const questionId = card.dataset.id;
                    const questionIndex = questions.findIndex(q => q.id === questionId);
                    
                    if (questionIndex !== -1) {
                        questions.splice(questionIndex, 1);
                        card.remove();
                        
                        // Update question numbers
                        updateQuestionNumbers();
                    }
                });
            }
            
            function addOption(optionsList) {
                const optionItem = document.createElement('div');
                optionItem.className = 'option-item';
                
                const optionInput = document.createElement('input');
                optionInput.type = 'text';
                optionInput.className = 'option-text';
                optionInput.placeholder = `Option ${optionsList.children.length + 1}`;
                
                const correctInput = document.createElement('input');
                correctInput.type = 'radio';
                correctInput.name = `correct-${optionsList.closest('.question-card').dataset.id}`;
                correctInput.className = 'correct-option';
                
                const correctLabel = document.createElement('label');
                correctLabel.textContent = 'Correct';
                
                const removeBtn = document.createElement('button');
                removeBtn.type = 'button';
                removeBtn.className = 'remove-btn';
                removeBtn.textContent = '×';
                removeBtn.addEventListener('click', () => {
                    const questionCard = optionsList.closest('.question-card');
                    const questionId = questionCard.dataset.id;
                    const questionIndex = questions.findIndex(q => q.id === questionId);
                    const optionIndex = Array.from(optionsList.children).indexOf(optionItem);
                    
                    if (questionIndex !== -1 && optionIndex !== -1) {
                        // Remove option from array
                        questions[questionIndex].options.splice(optionIndex, 1);
                        
                        // Update correct answer index if needed
                        if (questions[questionIndex].correctAnswerIndex === optionIndex) {
                            questions[questionIndex].correctAnswerIndex = null;
                        } else if (questions[questionIndex].correctAnswerIndex > optionIndex) {
                            questions[questionIndex].correctAnswerIndex--;
                        }
                        
                        // Update correct answer indices for multiple answers
                        if (questions[questionIndex].correctAnswerIndices.includes(optionIndex)) {
                            questions[questionIndex].correctAnswerIndices = 
                                questions[questionIndex].correctAnswerIndices.filter(i => i !== optionIndex);
                        }
                        
                        questions[questionIndex].correctAnswerIndices = 
                            questions[questionIndex].correctAnswerIndices.map(i => i > optionIndex ? i - 1 : i);
                    }
                    
                    // Remove from DOM
                    optionItem.remove();
                    
                    // Update option numbers
                    updateOptionNumbers(optionsList);
                });
                
                // Add event listeners
                optionInput.addEventListener('input', () => {
                    const questionCard = optionsList.closest('.question-card');
                    const questionId = questionCard.dataset.id;
                    const questionIndex = questions.findIndex(q => q.id === questionId);
                    const optionIndex = Array.from(optionsList.children).indexOf(optionItem);
                    
                    if (questionIndex !== -1 && optionIndex !== -1) {
                        questions[questionIndex].options[optionIndex] = optionInput.value;
                    }
                });
                
                correctInput.addEventListener('change', () => {
                    if (correctInput.checked) {
                        const questionCard = optionsList.closest('.question-card');
                        const questionId = questionCard.dataset.id;
                        const questionIndex = questions.findIndex(q => q.id === questionId);
                        const optionIndex = Array.from(optionsList.children).indexOf(optionItem);
                        
                        if (questionIndex !== -1) {
                            const isMultiple = questions[questionIndex].allowMultipleAnswers;
                            
                            if (!isMultiple) {
                                // Single answer mode
                                questions[questionIndex].correctAnswerIndex = optionIndex;
                            } else {
                                // Multiple answers mode
                                if (!questions[questionIndex].correctAnswerIndices.includes(optionIndex)) {
                                    questions[questionIndex].correctAnswerIndices.push(optionIndex);
                                }
                            }
                        }
                    }
                });
                
                // Append elements
                optionItem.appendChild(optionInput);
                optionItem.appendChild(correctInput);
                optionItem.appendChild(correctLabel);
                optionItem.appendChild(removeBtn);
                optionsList.appendChild(optionItem);
            }
            
            function addIdentificationAnswer(answersList) {
                const answerItem = document.createElement('div');
                answerItem.className = 'option-item';
                
                const answerInput = document.createElement('input');
                answerInput.type = 'text';
                answerInput.className = 'multiple-answer';
                answerInput.placeholder = `Enter a correct answer`;
                
                const removeBtn = document.createElement('button');
                removeBtn.type = 'button';
                removeBtn.className = 'remove-btn';
                removeBtn.textContent = '×';
                removeBtn.addEventListener('click', () => {
                    const questionCard = answersList.closest('.question-card');
                    const questionId = questionCard.dataset.id;
                    const questionIndex = questions.findIndex(q => q.id === questionId);
                    const answerIndex = Array.from(answersList.children).indexOf(answerItem);
                    
                    if (questionIndex !== -1 && answerIndex !== -1) {
                        // Remove answer from array
                        if (Array.isArray(questions[questionIndex].correctAnswerList)) {
                            questions[questionIndex].correctAnswerList.splice(answerIndex, 1);
                        }
                    }
                    
                    // Remove from DOM
                    answerItem.remove();
                });
                
                // Add event listeners
                answerInput.addEventListener('input', () => {
                    const questionCard = answersList.closest('.question-card');
                    const questionId = questionCard.dataset.id;
                    const questionIndex = questions.findIndex(q => q.id === questionId);
                    const answerIndex = Array.from(answersList.children).indexOf(answerItem);
                    
                    if (questionIndex !== -1 && answerIndex !== -1) {
                        if (!Array.isArray(questions[questionIndex].correctAnswerList)) {
                            questions[questionIndex].correctAnswerList = [];
                        }
                        questions[questionIndex].correctAnswerList[answerIndex] = answerInput.value;
                    }
                });
                
                // Append elements
                answerItem.appendChild(answerInput);
                answerItem.appendChild(removeBtn);
                answersList.appendChild(answerItem);
            }
            
            function updateMCQInputType(card, isMultiple) {
                const optionsList = card.querySelector('.options-list');
                const options = optionsList.querySelectorAll('.option-item');
                const questionId = card.dataset.id;
                
                options.forEach((option, index) => {
                    const oldInput = option.querySelector('.correct-option');
                    const isChecked = oldInput.checked;
                    
                    // Create new input with appropriate type
                    const newInput = document.createElement('input');
                    newInput.type = isMultiple ? 'checkbox' : 'radio';
                    newInput.className = 'correct-option';
                    newInput.name = isMultiple ? `correct-${questionId}-${index}` : `correct-${questionId}`;
                    newInput.checked = isChecked;
                    
                    // Add event listener
                    newInput.addEventListener('change', () => {
                        const questionIndex = questions.findIndex(q => q.id === questionId);
                        
                        if (questionIndex !== -1) {
                            if (!isMultiple) {
                                // Single answer mode
                                questions[questionIndex].correctAnswerIndex = index;
                            } else {
                                // Multiple answers mode
                                if (newInput.checked) {
                                    if (!questions[questionIndex].correctAnswerIndices.includes(index)) {
                                        questions[questionIndex].correctAnswerIndices.push(index);
                                    }
                                } else {
                                    questions[questionIndex].correctAnswerIndices = 
                                        questions[questionIndex].correctAnswerIndices.filter(i => i !== index);
                                }
                            }
                        }
                    });
                    
                    // Replace old input with new one
                    oldInput.parentNode.replaceChild(newInput, oldInput);
                });
            }
            
            function updateQuestionNumbers() {
                const questionCards = questionsList.querySelectorAll('.question-card');
                questionCards.forEach((card, index) => {
                    card.querySelector('.question-number').textContent = index + 1;
                });
                questionCounter = questionCards.length;
            }
            
            function updateOptionNumbers(optionsList) {
                const options = optionsList.querySelectorAll('.option-item');
                options.forEach((option, index) => {
                    const input = option.querySelector('.option-text');
                    input.placeholder = `Option ${index + 1}`;
                });
            }
            
            function exportExam() {
                // Validate exam has a title
                if (!examTitle.value.trim()) {
                    showNotification('Please enter an exam title before exporting', 'error');
                    return;
                }
                
                // Validate questions
                if (questions.length === 0) {
                    showNotification('Please add at least one question before exporting', 'error');
                    return;
                }
                
                // Prepare data for export
                const exportData = {
                    version: '1.0',
                    exportDate: new Date().toISOString(),
                    exam: {
                        title: examTitle.value,
                        description: examDescription.value,
                        due_date: examDueDate.value ? new Date(examDueDate.value).toISOString() : null,
                        questions: questions.map(q => {
                            // Format the question for export
                            let correctAnswer;
                            
                            if (q.type === 'mcq') {
                                if (q.allowMultipleAnswers) {
                                    // For multiple correct answers, get the text of selected options
                                    correctAnswer = q.correctAnswerIndices.map(index => q.options[index]);
                                } else {
                                    // For single correct answer
                                    correctAnswer = q.correctAnswerIndex !== null ? q.options[q.correctAnswerIndex] : '';
                                }
                            } else {
                                // For identification questions
                                if (q.allowMultipleAnswers) {
                                    correctAnswer = q.correctAnswerList;
                                } else {
                                    correctAnswer = q.correctAnswer;
                                }
                            }
                            
                            return {
                                type: q.type,
                                question_text: q.question,
                                options: q.type === 'mcq' ? q.options : null,
                                correct_answer: correctAnswer,
                                points: q.points || 1,
                                allow_multiple_answers: q.allowMultipleAnswers
                            };
                        })
                    }
                };
                
                // Convert to JSON string
                const jsonString = JSON.stringify(exportData, null, 2);
                
                // Create blob and download link
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                
                // Set download attributes
                link.href = url;
                link.download = `exam_${examTitle.value.replace(/\s+/g, '_').toLowerCase()}.json`;
                
                // Trigger download
                document.body.appendChild(link);
                link.click();
                
                // Clean up
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
                
                showNotification('Exam exported successfully!', 'success');
            }
            
            function importExam(event) {
                const file = event.target.files[0];
                if (!file) return;
                
                // Check file size (limit to 10MB)
                if (file.size > 10 * 1024 * 1024) {
                    showNotification('File too large. Maximum size is 10MB.', 'error');
                    return;
                }
                
                // Check file type
                if (file.type !== 'application/json' && !file.name.endsWith('.json')) {
                    showNotification('Invalid file type. Please select a JSON file.', 'error');
                    return;
                }
                
                const reader = new FileReader();
                
                reader.onload = function(e) {
                    try {
                        // Parse JSON
                        const importData = JSON.parse(e.target.result);
                        
                        // Validate structure
                        if (!importData.exam || !importData.version) {
                            throw new Error('Invalid exam file format');
                        }
                        
                        // Clear current exam
                        examTitle.value = '';
                        examDescription.value = '';
                        examDueDate.value = '';
                        questions = [];
                        questionsList.innerHTML = '';
                        questionCounter = 0;
                        
                        // Set exam details
                        examTitle.value = importData.exam.title || 'Imported Exam';
                        examDescription.value = importData.exam.description || '';
                        
                        // Format and set date if available
                        if (importData.exam.due_date) {
                            const dueDate = new Date(importData.exam.due_date);
                            const year = dueDate.getFullYear();
                            const month = String(dueDate.getMonth() + 1).padStart(2, '0');
                            const day = String(dueDate.getDate()).padStart(2, '0');
                            const hours = String(dueDate.getHours()).padStart(2, '0');
                            const minutes = String(dueDate.getMinutes()).padStart(2, '0');
                            examDueDate.value = `${year}-${month}-${day}T${hours}:${minutes}`;
                        }
                        
                        // Process questions
                        if (importData.exam.questions && Array.isArray(importData.exam.questions)) {
                            importData.exam.questions.forEach(importedQuestion => {
                                // Add a new question card
                                addNewQuestion();
                                
                                // Get the last added question card
                                const questionCard = questionsList.lastElementChild;
                                const questionId = questionCard.dataset.id;
                                const questionIndex = questions.length - 1;
                                
                                // Set question type
                                const typeButtons = questionCard.querySelectorAll('.type-btn');
                                typeButtons.forEach(btn => {
                                    if (btn.dataset.type === importedQuestion.type) {
                                        btn.click(); // Trigger the click event to update UI
                                    }
                                });
                                
                                // Set question text
                                const questionTextInput = questionCard.querySelector('.question-text');
                                questionTextInput.value = importedQuestion.question_text || '';
                                questions[questionIndex].question = importedQuestion.question_text || '';
                                
                                // Set multiple answers toggle
                                const multipleAnswersToggle = questionCard.querySelector('.allow-multiple');
                                multipleAnswersToggle.checked = importedQuestion.allow_multiple_answers || false;
                                
                                // Trigger change event to update UI
                                const changeEvent = new Event('change');
                                multipleAnswersToggle.dispatchEvent(changeEvent);
                                
                                // Set points
                                const pointsInput = questionCard.querySelector('.question-points');
                                pointsInput.value = importedQuestion.points || 1;
                                questions[questionIndex].points = importedQuestion.points || 1;
                                
                                // Handle question type specific data
                                if (importedQuestion.type === 'mcq') {
                                    // Clear default options
                                    const optionsList = questionCard.querySelector('.options-list');
                                    optionsList.innerHTML = '';
                                    questions[questionIndex].options = [];
                                    
                                    // Add imported options
                                    if (importedQuestion.options && Array.isArray(importedQuestion.options)) {
                                        importedQuestion.options.forEach((optionText, optIndex) => {
                                            // Add option to UI
                                            addOption(optionsList);
                                            
                                            // Set option text
                                            const optionItems = optionsList.querySelectorAll('.option-item');
                                            const lastOption = optionItems[optionItems.length - 1];
                                            const optionInput = lastOption.querySelector('.option-text');
                                            optionInput.value = optionText;
                                            
                                            // Update option in questions array
                                            questions[questionIndex].options.push(optionText);
                                            
                                            // Check if this option is correct
                                            let correctAnswer = importedQuestion.correct_answer;
                                            if (importedQuestion.allow_multiple_answers) {
                                                // For multiple correct answers
                                                if (Array.isArray(correctAnswer) && correctAnswer.includes(optionText)) {
                                                    const correctInput = lastOption.querySelector('.correct-option');
                                                    correctInput.checked = true;
                                                    
                                                    // Add to correctAnswerIndices
                                                    questions[questionIndex].correctAnswerIndices.push(optIndex);
                                                }
                                            } else {
                                                // For single correct answer
                                                if (correctAnswer === optionText) {
                                                    const correctInput = lastOption.querySelector('.correct-option');
                                                    correctInput.checked = true;
                                                    
                                                    // Set correctAnswerIndex
                                                    questions[questionIndex].correctAnswerIndex = optIndex;
                                                }
                                            }
                                        });
                                    }
                                } else {
                                    // Identification question
                                    if (importedQuestion.allow_multiple_answers) {
                                        // Multiple correct answers
                                        const multipleAnswersList = questionCard.querySelector('.multiple-answers-list');
                                        multipleAnswersList.innerHTML = '';
                                        
                                        let correctAnswers = importedQuestion.correct_answer;
                                        if (!Array.isArray(correctAnswers)) {
                                            correctAnswers = [correctAnswers];
                                        }
                                        
                                        questions[questionIndex].correctAnswerList = [];
                                        
                                        correctAnswers.forEach((answer, idx) => {
                                            // Add answer field to UI
                                            addIdentificationAnswer(multipleAnswersList);
                                            
                                            // Set answer text
                                            const answerItems = multipleAnswersList.querySelectorAll('.option-item');
                                            const lastAnswer = answerItems[answerItems.length - 1];
                                            const answerInput = lastAnswer.querySelector('.multiple-answer');
                                            answerInput.value = answer;
                                            
                                            // Update answer in questions array
                                            questions[questionIndex].correctAnswerList.push(answer);
                                        });
                                    } else {
                                        // Single correct answer
                                        const correctAnswerInput = questionCard.querySelector('.correct-answer');
                                        correctAnswerInput.value = importedQuestion.correct_answer || '';
                                        questions[questionIndex].correctAnswer = importedQuestion.correct_answer || '';
                                    }
                                }
                            });
                        }
                        
                        showNotification(`Imported exam "${examTitle.value}" with ${importData.exam.questions.length} questions`, 'success');
                    } catch (error) {
                        console.error('Error importing exam:', error);
                        showNotification(`Failed to import exam: ${error.message}`, 'error');
                    }
                };
                
                reader.onerror = function() {
                    showNotification('Error reading file', 'error');
                };
                
                reader.readAsText(file);
                
                // Reset the file input
                event.target.value = null;
            }
            
            function showNotification(message, type = 'success') {
                const notification = document.createElement('div');
                notification.className = `notification ${type}`;
                notification.textContent = message;
                
                notificationsDiv.appendChild(notification);
                
                // Remove notification after 5 seconds
                setTimeout(() => {
                    notification.remove();
                }, 5000);
            }
        });
    </script>
</body>
</html>
